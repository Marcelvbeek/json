{"version":3,"sources":["../../server/auth/authController.js"],"names":["jwt","require","passwordEncrypter","getToken","req","headers","authorization","split","query","token","body","authController","res","userModel","find","username","err","users","length","json","password","name","newUser","encrypt","role","save","sign","data","secret","expiresIn","success","message","next","verify","decoded","status","send","findOne","user","compare"],"mappings":"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","file":"authController.js","sourcesContent":["const jwt = require('jsonwebtoken')\nimport config from '../database/config'\nimport models from '../database/index'\nimport passEncrypter from './passwordEncrypter'\n\nconst passwordEncrypter = new passEncrypter()\n\nfunction getToken(req) {\n    if (req.headers.authorization && req.headers.authorization.split(' ')[0] === 'Bearer') {\n        return req.headers.authorization.split(' ')[1];\n    } \n    else if (req.query && req.query.token) {\n        return req.query.token;\n    }\n    else if(req.body && req.body.token) {\n        return req.body.token;\n    }\n    else if(req.headers['x-access-token']) {\n        return req.headers['x-access-token']\n    }\n    return null;\n}\n\nclass authController {\n    constructor() {\n\n    }\n\n    \n\n    addAcount(req, res) {\n        models.userModel.find({'username': req.body.username}, (err, users) => {\n            if(users && users.length) {\n                res.json({\n                    'error': 'User with username ' + req.body.username + ' found'\n                })\n            }\n            else {\n                if(req.body.username && req.body.password && req.body.name) {\n                    const newUser = new models.userModel({\n                        name: req.body.name, \n                        username: req.body.username,\n                        password: passwordEncrypter.encrypt(req.body.password), \n                        role: 1\n                    })\n                    newUser.save()\n\n                    // if user is found and password is right\n                    // create a token\n                    var token = jwt.sign(\n                        {\n                            data: newUser\n                        }, \n                        config.secret, \n                        { \n                            expiresIn: 60 * 60 \n                        }\n                    );\n\n                    // return the information including token as JSON\n                    res.json({\n                        success: true,\n                        message: 'Enjoy your token!',\n                        token: token\n                    });\n                }\n                else {\n                    res.json({\n                        'error': 'Check if everything is filled correctly'\n                    })\n                }\n            }\n        })\n    }\n\n    verifyToken(req, res, next) {\n\n        const token = getToken(req)\n\n        // decode token\n        if (token) {\n\n            jwt.verify(\n                token, \n                config.secret, \n            (err, decoded) => {      \n                if (err) {\n                    return res.json({ success: false, message: 'Failed to authenticate token.' });    \n                } \n                else {\n                    // if everything is good, save to request for use in other routes\n                    req.decoded = decoded;    \n                    next();\n                }\n            });\n\n        } else {\n\n            // if there is no token\n            // return an error\n            return res.status(403).send({ \n                success: false, \n                message: 'No token provided.' \n            });\n\n        }\n    }\n\n    login(req, res) {\n        models.userModel.findOne({\n            username: req.body.username\n        }, \n        (err, user) => {\n\n            if (err) throw err;\n\n            if (!user) {\n                res.json({ success: false, message: 'Authentication failed. User not found.' });\n            } \n            else if (user) {\n\n                // check if password matches\n                if (!passwordEncrypter.compare(req.body.password, user.password)) {\n                    res.json({ success: false, message: 'Authentication failed. Wrong password.' });\n                } \n                else {\n\n                    // if user is found and password is right\n                    // create a token\n                    var token = jwt.sign(\n                        {\n                            data: user\n                        }, \n                        config.secret, \n                        { \n                            expiresIn: 60 * 60 \n                        }\n                    );\n\n                    // return the information including token as JSON\n                    res.json({\n                        success: true,\n                        message: 'Enjoy your token!',\n                        token: token\n                    });\n                }   \n\n                }\n\n        });\n    }\n    \n}\n\nexport default authController"]}